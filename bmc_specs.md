-------------------------------------------------------------------------------
created	:	Thu Nov 14 08:58:20 CST 2024

date	:	.

-------------------------------------------------------------------------------
+ ast2600evb
  + BAS-6101
  + CB-1941
  + CB-1941_test
  + CB-1942
  + CB-1942_46
  + CB-1945
  + CB-1946
  + CB-1946_dev
  + HEAD -> origin/IS-B135
  + IS-5121
  + IS-B135
  + LTS-v13
  + SNIPET_ONE_400G
  + VECNA
  + onboard

+ ast2500evb
  + 191-eip-535830-lts12-3rc-defensics-icmpv6-icmpv6-protocol-too-many-fail-on-rc-build-previous-tb1-build-was-fine
  + 5098-eip-566969-ast2500evb-lts-security-rmcp-channel-encryption
  + Add_password_policy_feature
  + AddingActiveBranchMRTemplate
  + Adding_changes_for_Aux10digit_support_EIP#540985
  + Aewin
  + BootingTimeImprovemement_stage1
  + BootingTimeImprovemement_stage2
  + CB-1932
  + CB-1937
  + CB-1937_Beijing_Infosec_v1.0.42I
  + CB-1937_TOPSEC
  + CB-1937_china
  + CB-1939
  + CB-1939_Beijing_Infosec_v1.0.20I
  + CB-1939_Beijing_Infosec_v1.0.30I
  + CB-1939_SangFor
  + CB-1939_old
  + Corrected_License_Scheduled_Job_Entry_CRON
  + EIP594275_Cannot_update_BIOS_firmware_image_via_web_ui
  + EIP_478253_INCREASE_MAX_IPMI_USER_NUMBER
  + EIP_499446_PASSWD_VALIDATION_AST2500
  + EIP_560926_Support_Winbond_SPI_W25Q02JV
  + FixAST2500BootUpFailIssue
  + FixLibIPMIParMDSBuildFail
  + Fix_the_restore_config_fail
  + FixeBootFromeMMCSDIssue
  + GIT_TASK_1004
  + HEAD -> origin/master
  + IPV6_conformance_Fixes
  + IPV6_conformance_fixes
  + IS-5221
  + Increase_bootloader_section_size
  + LTS-v12
  + LTS-v12-Dev
  + LTS-v12-K5.2
  + LTS_v12_update_3.00
  + LTS_v12_update_3.00-Dev
  + LTS_v12_update_3.00-Dev_K5.4
  + LTS_v12_update_3.00-UpgradeKernelTo5.4
  + PY3
  + Python3
  + SNMP_USER_SECURITY_ENHANCEMENT
  + SSIF_Feature_Development
  + SUPPORT_FOR_ADDING_OEMHPM_COMPONENT_VIA_PDKHOOKS
  + SupportGigaSPI
  + UpdateLTS12_3CustomerBranchProjectfileSetting
  + active_tree
  + add-ci
  + add_sw_failsafe_contigiousflash_support
  + add_swdual_failsafe_support
  + added_ddf_to_par
  + ast2500_smash_fix_override
  + bootdelay_change
  + change_null_user_privilege
  + changes_for_fortify_check_buffer_overflow
  + cherry-pick-14c397e4
  + cherry-pick-24d45dfd
  + cherry-pick-2d5a6d90
  + cherry-pick-511b10ba
  + cherry-pick-c792730b
  + cifs_smb_config
  + commit_check
  + enable_cifs_smbv2
  + fix_serial_interface
  + fix_vgafunchandshake_scu
  + git_task_1004
  + kernel-target-u-boot-upgrade
  + kernel_upgrade_5499_ast2500
  + lan_dram_support_kernel5
  + master
  + multiple_EIP_fixes_for_spichips
  + nfs-test
  + onboard
  + optimize_ci
  + patch-1
  + python3_fix
  + roy
  + sample
  + sdhci_driver_support
  + sel_Event_Log
  + sel_event_log
  + smash_fix_ast2500
  + sync_up_for_fortify
  + systemd
  + target_kernel_upgrade
  + test-tag
  + testbranch1
  + testbranch2-from-testbranch1
  + v12-update-1.04
  + v12-update-1.05-branch
  + v12-update-1.06-branch
  + v12-update-1.07-branch
  + v12-update-2.01-branch
  + v12-update-2.02-branch
  + v12-update-2.03-branch
  + v12-update-2.04-branch
  + v12-update-2.05-branch
  + v12-update-2.06-branch
  + v12-update-3.00
  + v12-update-3.00-RC1-branch
  + v12-update-3.01-branch
  + v12-update-3.02-branch
  + v12-update-3.03-branch

-------------------------------------------------------------------------------

# jeffrey #
| project           | codebase | branch |
|:-----------------:|:--------:|:------:|
| CB-1946           |          |        |
| BAS-6103          |          |        |
| BAS-6101 (*1)     |          |        |
| BAS-6101          |          |        |
| BAS-6101_Redfish  |          |        |
| IS-5121           |          |        |
| CB-1927           |          |        |
| CB-1934           |          |        |
| CB-1936           |          |        |
| CB-1339           |          |        |
| CB-1941           |          |        |
| CB-1727           |          |        |

| project           | codebase   | branch              |   | PRJ                   |
|:-----------------:|:----------:|:-------------------:|---|:---------------------:|
| CB-1946           | ast2600evb | CB-1946             |   | CB-1946.PRJ           |
| BAS-6103          | archercity |                     |   | BAS-6103.PRJ          |
| BAS-6101 (*1)     | ast2600evb |                     |   |                       |
| BAS-6101          | archercity | BAS-6101            |   | BAS-6101.PRJ          |
| BAS-6101\_Redfish | archercity | BAS-6101\_Redfish   |   | BAS-6101\_Redfish.PRJ |
| IS-5121           | archercity |                     |   | IS-5121\_Redfish.PRJ  |
| CB-1927           | wolfpass   | CB-1932\_topsec1927 |   |                       |
| CB-1934           | ethanol-x  | CB-1934\_TOPSEC     |   |                       |
| CB-1936           | ast2500evb | CB-1936\_TOPSEC     |   |                       |
| CB-1339           | ethanol-x  | CB-1939\_TOPSEC     |   |                       |
| CB-1941           | ast2600evb | CB-1941             |   | CB-1941.PRJ           |
| CB-1727           | RR11_7     |                     |   |                       |
|                   |            |                     |   |                       |
| CB-1945           |            |                     |   |                       |

+ P1
fan 0 status and latter
buzzer
+ P2
led
sel



if `#ifndef CONFIG_SPX_FEATURE_INIT_DUTY`
`CONVIF_SPX`
就代表 PRJ file 有可以調整的

fan
L:`/ast2600evb/packages/bootloader/packages/Bootloader_20XX_oem-src/data/005-CB-1946-board-init.patch`

在 MDSTOOL ->
L:`customizable/Bootloader_20CCz-oem-13.2.0.0.0/data/004-add-aspeed-pwm-driver.patch`

`pwm` `aspeed`

























-------------------------------------------------------------------------------


如果有時間 我想看看這個!!
CB-1946 
BAS-6103 
IS-5121 
CB-1927
CB-1936 
CB-1339 
bule-line -> file ??

<!-- Fri Nov 15 14:20:18 CST 2024 -->



# bootload #


# smartfan #




#  sel  #
`IPMI_ADD_SEL_ENTRY`


#  uint8_t #
only use linux vscode (didnt vscode ssh)
L:`/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h`
```h			================start================
#ifndef _BITS_STDINT_UINTN_H
#define _BITS_STDINT_UINTN_H	1

#include <bits/types.h>

typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;

284 13:00~13:30


#endif /* bits/stdint-uintn.h */
```


L:`/usr/include/x86_64-linux-gnu/bits/types.h`
```h			================start================
#ifndef	_BITS_TYPES_H
#define	_BITS_TYPES_H	1

#include <features.h>
#include <bits/wordsize.h>

/* Convenience types.  */
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;

/* Fixed-size types, underlying types depend on word size and compiler.  */
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
```

# sel  #
`IPMI_ADD_SEL_ENTRY`
+ assert `0x6F`
+ deassert `0xEF`
造成這樣的原因 是 bit 1 2 4 8 bit
+ if assert

| [3] | [2] | [1] | [0] |
|:---:|:---:|:---:|:---:|
| 8   | 4   | 2   | 1   |

    ====>  2 + 4 		= 6  (0x6) assert
    ====>  2 + 4 + 8	= 14 (0xE) deassert


L:`/ast2600evb/packages/libipmipdk-ARM-AST2600-AST2600EVB-AMI-src/data/PDKInt.c`
`void AEWIN_GPIO_Interrupt_Handler(IPMI_INTInfo_T *IntInfo)`

## check-bmc-watchdog  ##
L:`/ast2600evb/packages/common/packages/libAEWIN-src/data/init.c`
```C			================start================
    pf = fopen("/Aewin_config/WDT_count", "r+");
    if(pf != NULL)
    {
        fscanf(pf, "%u", &count);

        mem_read(0x1E785030, &value);
        value &= 0x0000FF00;	// need to look it
        value >>= 8;			// need to look it
        if(value == 0)
        {
            fseek(pf, 0, SEEK_SET);
            fprintf(pf, "0");
            fclose(pf);
            return;
        }

        if(count != value)
        {
            IPMI_ADD_SEL_ENTRY(0x00, 0x28, 0x6F030000, 1);
            fseek(pf, 0, SEEK_SET);
            fprintf(pf, "%u", value);
        }

        fclose(pf);
    }
```

## thread-status-chassis-intrusion ##
L:`/ast2600evb/packages/common/packages/libAEWIN-src/data/device/chassis_intrusion.c`
```c			================start================
void* thread_status_chassis_intrusion(void *pArg)
{
    int last_chassis_intrusion = -1;
    int chassis_intrusion = -1;
	if (0)
	{
		pArg = pArg;
	}

    //SD20 peter.cy.chen polling to check chassis intrusion, if value is not zero, call clear_chassis_intrusion to clear value
	while (1)
	{
        chassis_intrusion = get_chassis_intrusion();
        if (chassis_intrusion >= 0)
        {
            if (last_chassis_intrusion != chassis_intrusion)
            {
                if (chassis_intrusion)
                {
                    //SD20 peter.cy.chen get chassis intrusion assert
                    IPMI_ADD_SEL_ENTRY(0x00, 0x05, 0x6F000000, 1);
                }
                else
                {
                    if (last_chassis_intrusion == 1)
                    {
                        //SD20 peter.cy.chen get chassis intrusion deassert
                        IPMI_ADD_SEL_ENTRY(0x00, 0x05, 0xEF000000, 1);
                    }
                }

                last_chassis_intrusion = chassis_intrusion;
            }

            clear_chassis_intrusion();
        }
        WAIT(3, 0);
	}

	return 0;
}
```

## psu  ##
L:`/ast2600evb/packages/common/packages/libAEWIN-src/data/device/psu.c`
```c			================start================
if((PSU_BMC[i].Status_word_pre ^ PSU_BMC[i].Status_word) & 0xFDFF)
{
    IPMI_ADD_SEL_ENTRY(0x00, (PSU_BMC[i].Sensor_Number << 8) | 0x08, 0x6FA80000 | (pread_buf[0] << 8) | pread_buf[1], 1);
    PSU_BMC[i].Status_word_pre = PSU_BMC[i].Status_word;
}
```

## aewin-private-cmd-aewin-dimm-led ##
L:`/ast2600evb/packages/common/packages/libAEWIN-src/data/ipmi_cmd/AewinPrivateCmd.c`
```c			================start================
cache32 = 0xEFA70000;
BITS_AREA_SET_VALUE(&cache32, 7, 4, gDIMM[num].Channel_No);
BITS_AREA_SET_VALUE(&cache32, 3, 0, gDIMM[num].Cpu_No);
BITS_AREA_SET_VALUE(&cache32, 11, 8, 0x00);
BITS_AREA_SET_VALUE(&cache32, 15, 12, gDIMM[num].Slot_No);
IPMI_ADD_SEL_ENTRY(0x00, 0x0C, cache32, 1);
```

## IPMI_INTInfo_T ##
`IPMI_INTInfo_T`
L:`/ast2600evb/packages/common/packages/ipmi_dev-src/data/ipmi_int.h`
```C			================start================
typedef struct {

    void					*pint_hndlr;		/* interrupt handler for this routine */
    int						int_num;		/* interrupt number for this handler */
    IPMI_INTSource_E		Source;			/* Interrupt source */
    INT8U					SensorNum;		/* Used only for Sensor monitoring */
    INT8U					SensorType;		/* Used only for Sensor monitoring */
    IPMI_INTTrig_method_E	TriggerMethod;		/* Interrupt trigger method */
    IPMI_INTTrig_type_E		TriggerType;		/* Interrupt trigger type */
    int 					int_type;				/* Interrupt type used only for SWC Handler */
    INT8U 					int_input_data;			/* Interrupt input data used only for SWC */
    INT8U					reading_on_assertion;	/* Reading/Interrupt information when interrupt occured */
    INT8U                   SensorOwnerLun;

} IPMI_INTInfo_T;
```
`AEWIN_GPIO_Interrupt_Handler`
L:`/ast2600evb/packages/libipmipdk-ARM-AST2600-AST2600EVB-AMI-src/data/PDKInt.c`
```C			================start================
IPMI_INTInfo_T m_IntInfo [] =
{
	{AEWIN_GPIO_Interrupt_Handler, GPIO_UIDBTN_N,               INT_REG_HNDLR, 0, NON_THRESHOLD_SENSOR, IPMI_INT_TRIGGER_EDGE, IPMI_INT_BOTH_EDGES, 0, 0, 0 ,0},
	{AEWIN_GPIO_Interrupt_Handler, GPIO_PCH_S3_N,               INT_REG_HNDLR, 0, NON_THRESHOLD_SENSOR, IPMI_INT_TRIGGER_EDGE, IPMI_INT_BOTH_EDGES, 0, 0, 0 ,0},
#if defined(GPIO_PCH_S4_N)
    {AEWIN_GPIO_Interrupt_Handler, GPIO_PCH_S4_N,               INT_REG_HNDLR, 0, NON_THRESHOLD_SENSOR, IPMI_INT_TRIGGER_EDGE, IPMI_INT_BOTH_EDGES, 0, 0, 0 ,0},
#endif

#if defined(GPIO_PCH_S5_N)
    {AEWIN_GPIO_Interrupt_Handler, GPIO_PCH_S5_N,               INT_REG_HNDLR, 0, NON_THRESHOLD_SENSOR, IPMI_INT_TRIGGER_EDGE, IPMI_INT_BOTH_EDGES, 0, 0, 0 ,0},
#endif
    {AEWIN_GPIO_Interrupt_Handler, GPIO_PSU_ALL_PWROK,          INT_REG_HNDLR, 0, NON_THRESHOLD_SENSOR, IPMI_INT_TRIGGER_EDGE, IPMI_INT_BOTH_EDGES, 0, 0, 0 ,0},
    {AEWIN_GPIO_Interrupt_Handler, GPIO_RST_RSMRST_N,           INT_REG_HNDLR, 0, NON_THRESHOLD_SENSOR, IPMI_INT_TRIGGER_EDGE, IPMI_INT_BOTH_EDGES, 0, 0, 0 ,0},
    {AEWIN_GPIO_Interrupt_Handler, GPIO_RST_PLTRST_N,           INT_REG_HNDLR, 0, NON_THRESHOLD_SENSOR, IPMI_INT_TRIGGER_EDGE, IPMI_INT_BOTH_EDGES, 0, 0, 0 ,0},
    {AEWIN_GPIO_Interrupt_Handler, GPIO_BIOS_POST_CMPLT_N,      INT_REG_HNDLR, 0, NON_THRESHOLD_SENSOR, IPMI_INT_TRIGGER_EDGE, IPMI_INT_BOTH_EDGES, 0, 0, 0 ,0},
	{AEWIN_GPIO_Interrupt_Handler, CPU_THERMTRIP_N,             INT_REG_HNDLR, 0, NON_THRESHOLD_SENSOR, IPMI_INT_TRIGGER_EDGE, IPMI_INT_BOTH_EDGES, 0, 0, 0 ,0},
	{AEWIN_GPIO_Interrupt_Handler, PCH_CATERR_N,                INT_REG_HNDLR, 0, NON_THRESHOLD_SENSOR, IPMI_INT_TRIGGER_EDGE, IPMI_INT_BOTH_EDGES, 0, 0, 0 ,0},
};
```

# pointer-to-the-handler-which-handles-the-interrupt-after-comming-out-of-the-interrutp #

## Interrupt Handling in Embedded Systems ##

When an interrupt occurs in an embedded system, the processor temporarily halts its current execution to service the interrupt. This is done by jumping to a special function known as an interrupt handler or interrupt service routine (ISR). After the ISR completes its task, control is returned to the point where the interrupt occurred.

## Pointer to the Interrupt Handler ##
A pointer to the handler is essentially a function pointer that points to the ISR. This allows the system to dynamically assign different handlers to different interrupts or change handlers at runtime.

Key Points
Function Pointer Definition:

typedef void (*InterruptHandler)(void);
This defines a type InterruptHandler which is a pointer to a function that takes no arguments and returns void.
Interrupt Handler Function:

voidin
void myInterruptHandler(void) {
    printf("Interrupt handled!\n");
}
This is a simple ISR that prints a message.
Setting the Interrupt Handler:

void setInterruptHandler(InterruptHandler handler) {
    handler();
}
This function takes a function pointer as an argument and calls the handler. In a real system, this would involve configuring hardware registers to point to the ISR.
Using the Function Pointer:

setInterruptHandler(myInterruptHandler);
This sets the interrupt handler to myInterruptHandler.
Summary
Interrupt Handler: A function that handles the interrupt.
Function Pointer: A pointer to the interrupt handler function.
Setting the Handler: Assigning the function pointer to the desired ISR.
This mechanism allows flexibility in handling interrupts, enabling dynamic assignment and changes to interrupt handlers as needed.
[ref-bingGPT]()

| 1                          | 2                                                                     |                                                           |
|:--------------------------:|:---------------------------------------------------------------------:|-----------------------------------------------------------|
| GPIO\_UIDBTN\_N            | clear_beep_alert                                                      |                                                           |
| GPIO\_PCH\_S3\_N           | sExtVar.sSysPWRStatus.Int\_notify\_S3 = 1                             |                                                           |
| GPIO\_PCH\_S4\_N           | s4\_check()                                                           |                                                           |
| GPIO\_PCH\_S5\_N           | s5\_check()                                                           |                                                           |
| GPIO\_PSU\_ALL\_PWROK      | per_ok_check                                                          |                                                           |
| GPIO\_BIOS\_POST\_CMPLT\_N | sExtVar.sSysPWRStatus.status\_Bios\_post\_cmplt = data\_cache & 0x01; | sExtVar.sSysPWRStatus.Int\_notify\_Bios\_post\_cmplt = 1; |
| GPIO\_RST\_PLTRST\_N       | plt_rst_check()                                                       | sExtVar.sSysPWRStatus.Int_notify_S3 = 1;                  |
|                            | plt_rst_check()                                                       | sExtVar.sSysPWRStatus.Int_notify_PLTRST = 1;              |
| GPIO\_RST\_RSMRST\_N       |                                                                       |                                                           |
| CPU\_THERMTRIP\_N          |                                                                       |                                                           |
| PCH\_CATERR\_N             |                                                                       |                                                           |




# system ACPI power state #
L:`/mnt/AEWIN/codebase/ast2600evb/ast2600evb/packages/common/packages/ipmitool-src/data/include/ipmitool/ipmi_sel.h`
```c			================start================
    /* System ACPI Power State */
    { 0x22, 0x00, 0xff, "S0/G0: working" },
    { 0x22, 0x01, 0xff, "S1: sleeping with system hw & processor context maintained" },
    { 0x22, 0x02, 0xff, "S2: sleeping, processor context lost" },
    { 0x22, 0x03, 0xff, "S3: sleeping, processor & hw context lost, memory retained" },
    { 0x22, 0x04, 0xff, "S4: non-volatile sleep/suspend-to-disk" },
    { 0x22, 0x05, 0xff, "S5/G2: soft-off" },
    { 0x22, 0x06, 0xff, "S4/S5: soft-off" },
    { 0x22, 0x07, 0xff, "G3: mechanical off" },
    { 0x22, 0x08, 0xff, "Sleeping in S1/S2/S3 state" },
    { 0x22, 0x09, 0xff, "G1: sleeping" },
    { 0x22, 0x0a, 0xff, "S5: entered by override" },
    { 0x22, 0x0b, 0xff, "Legacy ON state" },
    { 0x22, 0x0c, 0xff, "Legacy OFF state" },
    { 0x22, 0x0e, 0xff, "Unknown" },
```

L:`/mnt/AEWIN/codebase/ast2600evb/ast2600evb/packages/common/packages/libAEWIN-src/data/Include/sel.h`
```h			================start================
typedef struct
{
  uint8_t Sensor_No;
  uint8_t Sensor_type;
  uint8_t Event_type;         //[7:7]: => Event Dir 1-bit. Indicates the event transition direction. (0 = Assertion Event, 1 = Deassertion Event)
                              //[6:0]: => Event Type 7-bits. This field indicates the type of threshold crossing or state transition (trigger) that produced the
                              //event. This is encoded using the Event/Reading Type Code. See Section 42, Sensor and Event
                              //Code Tables.
  uint8_t Event_data1_custom; //[7:4]:x => don't care info after event data x, 0 is before 1; [3:0]: event_data1_offset
  uint8_t Event_data2;
  uint8_t Event_data3;
  uint8_t Led_status;
  uint8_t Beep_status;
  uint8_t Event_index; //[7]:0 => deassert, 1 => assert; [6:0]: event index
  INT16U  Gpio_num;
  INT32U  status_record;
  uint8_t Enable;
}EVENT_ALERT;
```

-------------------------------------------------------------------------------
Mon Nov 25 11:15:17 CST 2024
now sel part 1 is done

# beep #
`/mnt/AEWIN/codebase/ast2600evb/ast2600evb/packages/common/packages/libAEWIN-src/data/Include/beep.h`
```h			================start================
typedef enum
{
    ALARM_EMPTY                      = 0x00000000,
	ALARM_CPU0_PROCHOT               = 0x00000001,
	ALARM_CPU1_PROCHOT               = 0x00000002,
    ALARM_CPU0_VRHOT                 = 0x00000004,
    ALARM_CPU1_VRHOT                 = 0x00000008,
	ALARM_CPU0_MEMHOT                = 0x00000010,
	ALARM_CPU1_MEMHOT                = 0x00000020,
	ALARM_CPU_THERMTRIP              = 0x00000040,
	ALARM_CPU_ERROR0                 = 0x00000080,
	ALARM_CPU_ERROR1                 = 0x00000100,
	ALARM_CPU_ERROR2                 = 0x00000200,
	ALARM_PCH_CATERR                 = 0x00000400,
    ALARM_CMD_BUZZER                 = 0x04000000,
    ALARM_PSU_ERROR                  = 0x08000000,
    ALARM_PSU_WARNING                = 0x10000000,
    ALARM_FAN_ERROR                  = 0x20000000,
    ALARM_FAN_WARNING                = 0x40000000,
	STOP_ALARM_BUZZER                = 0x80000000,
    ALARM_IPMI_DISCRETE_EVENT_MASK   = 0x03FFFFFF,
    ALARM_ERROR_BUZZER_MASK          = 0x7BFFFFFF,
    ALARM_CMD_BUZZER_MASK            = 0x04000000,
}ALARM_BUZZER;
```

筆者從` ALARM_CPU0_PROCHOT               = 0x00000001,`
這裡 當時 是要寫 GPIO 的PIN
但是它顯示1U 但是並非是 GPIO

然後 這就是 //low level buzzer alert flag
現在要來看 alarm or beep or buzzer

`ret` == ` return`


### 1945_gCPU_thermtrip ###
`/mnt/AEWIN/codebase/malo/ast2600evb/packages/common/packages/libAEWIN-src/data/sys_info/status.c`
```c			================start================
if (gCPU_THERMTRIP)
{
	gpio_read_data(CPU_THERMTRIP_N, &cache);

	if (cache)
	{
		IPMI_ADD_SEL_ENTRY(0x00, 0x07, 0xEF010000, 1);
	}
	else
	{
		IPMI_ADD_SEL_ENTRY(0x00, 0x07, 0x6F010000, 1);
	}
	gCPU_THERMTRIP = 0;
}
```
```c			================start================
if (gCPU_CATERR)
{
	gpio_read_data(PCH_CATERR_N, &cache);

	if (cache)
	{
		IPMI_ADD_SEL_ENTRY(0x00, 0x07, 0xEF000000, 1);
	}
	else
	{
		IPMI_ADD_SEL_ENTRY(0x00, 0x07, 0x6F000000, 1);
	}
	gCPU_CATERR = 0;
}
```

# use ipmitool change gpio pin  #

```c			================start================
01234567
76543210
    0100
    0101
```
`ipmitool raw 0x1c 0x01 0x01 0x02 0x08 0x03 0x05`
`ipmitool raw 0x1c 0x01 0x01 0x02 0x08 0x03 0x04`
`/mnt/d/role/john_大神/Aewin IPMI command list_v3.7_2024_0423.xlsx`
`IPMI Private Command` -> `Interface Read Write`
| command name         | NetFn | CMD  |         | Byte#      | 1           | 2         | 3                | 4         | 5                                       | 6 |
|:--------------------:|:-----:|:----:|:-------:|:----------:|:-----------:|:---------:|:----------------:|:---------:|:---------------------------------------:|:-:|
|                      |       |      |         |            |             |           |                  |           |                                         |   |
| interface read write |       |      | request | data field | interface   | readwrite | group            | index     | direction value                         |   |
| interface read write | 0x1c  | 0x01 | request | note       | GPIO : 0x01 | Read:0x01 | A~AC : 0x01~0x1D | 0x00~0x07 | [7:4]reserver[3:2]direction [1;0] value |   |

##### J4-ipmi-privae-command #####
[7:4] Reserve
[3:2] Direction
No change : 1x
Output : 01 Input : 00
[1:0] Value
No change : 1x
High : 01 Low : 00
If set data field "ReadWrite" to be "Read", don't fill this byte.
